import cv2
import numpy as np
import matplotlib.pyplot as plt

import cv2
import numpy as np
import matplotlib.pyplot as plt

def get_points(mask: np.ndarray,
               eps_start: float = 0.001,
               eps_step: float = 0.001,
               eps_max: float = 0.1,
               subpixel_window: int = 7,
               refine_iterations: int = 3) -> np.ndarray:
    img = (mask.astype(np.uint8) * 255)
    
    contours, _ = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    if not contours:
        raise ValueError("Контуры не найдены - проверьте маску")

    contour = max(contours, key=cv2.contourArea)
    area = cv2.contourArea(contour)
    perimeter = cv2.arcLength(contour, True)
    circularity = (4 * np.pi * area) / (perimeter ** 2) if perimeter > 0 else 0
    hull = cv2.convexHull(contour)
    hull_perimeter = cv2.arcLength(hull, True)
    gray = cv2.GaussianBlur(img, (5, 5), 0)
    gray = np.float32(gray)
    hull_points = hull.squeeze().astype(np.float32)
    
    for _ in range(refine_iterations):
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 50, 0.0001)
        cv2.cornerSubPix(gray, hull_points, (subpixel_window, subpixel_window), (-1, -1), criteria)
    
    if circularity > 0.85 and len(contour) >= 5:
        ellipse = cv2.fitEllipse(contour)
        (x, y), (MA, ma), angle = ellipse
        
        angle_rad = np.deg2rad(angle)
        major_axis = np.array([np.cos(angle_rad), np.sin(angle_rad)])
        minor_axis = np.array([-np.sin(angle_rad), np.cos(angle_rad)])
        points = []
        for direction, length in [(major_axis, MA/2), (-major_axis, MA/2), 
                                 (minor_axis, ma/2), (-minor_axis, ma/2)]:
            pt = np.array([x, y]) + length * direction
            closest = None
            min_dist = float('inf')
            
            for p in contour:
                p = p[0]
                dist = np.linalg.norm(p - pt)
                if dist < min_dist:
                    min_dist = dist
                    closest = p
            
            if closest is not None:
                points.append(closest)
        
        if len(points) == 4:
            corners = np.array(points, dtype=np.float32)
    else:
        eps = eps_start
        best_approx = None
        best_eps = eps_start
        
        while eps <= eps_max:
            approx = cv2.approxPolyDP(hull_points, eps * hull_perimeter, True)
            if len(approx) >= 4 and len(approx) <= 6:
                if best_approx is None or len(approx) < len(best_approx):
                    best_approx = approx
                    best_eps = eps
                if len(approx) == 4:
                    break
            eps += eps_step

        if best_approx is None or len(best_approx) < 4:
            rect = cv2.minAreaRect(hull_points)
            corners = cv2.boxPoints(rect)
        else:
            if len(best_approx) > 4:
                curvatures = []
                for i in range(len(best_approx)):
                    p0 = best_approx[i-1][0]
                    p1 = best_approx[i][0]
                    p2 = best_approx[(i+1) % len(best_approx)][0]
                    
                    v1 = p0 - p1
                    v2 = p2 - p1
                    cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2) + 1e-5)
                    angle = np.arccos(np.clip(cos_angle, -1, 1))
                    curvatures.append(angle)
                
                indices = np.argsort(curvatures)[-4:]
                corners = np.array([best_approx[i][0] for i in indices])
            else:
                corners = best_approx.squeeze()
    
    refined_corners = []
    for corner in corners:
        x, y = corner
        roi_size = 15
        x_min = max(0, int(x) - roi_size)
        x_max = min(gray.shape[1], int(x) + roi_size + 1)
        y_min = max(0, int(y) - roi_size)
        y_max = min(gray.shape[0], int(y) + roi_size + 1)
        
        if x_min < x_max and y_min < y_max:
            roi = gray[y_min:y_max, x_min:x_max].copy()
            
            corners_roi = cv2.goodFeaturesToTrack(
                roi, maxCorners=1, qualityLevel=0.01,
                minDistance=5, blockSize=7, useHarrisDetector=True
            )
            
            if corners_roi is not None:
                rx, ry = corners_roi[0][0]
                refined_corners.append([x_min + rx, y_min + ry])
            else:
                refined_corners.append(corner)
        else:
            refined_corners.append(corner)
    
    corners = np.array(refined_corners)
    center = np.mean(corners, axis=0)
    angles = np.arctan2(corners[:, 1] - center[1], corners[:, 0] - center[0])
    sorted_indices = np.argsort(angles)
    sorted_corners = corners[sorted_indices]
    sums = np.sum(sorted_corners, axis=1)
    start_idx = np.argmin(sums)
    
    ordered_corners = np.roll(sorted_corners, -start_idx, axis=0)
    
    final_corners = []
    for corner in ordered_corners:
        pt = np.array([[[corner[0], corner[1]]]], dtype=np.float32)
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.0001)
        cv2.cornerSubPix(gray, pt, (5, 5), (-1, -1), criteria)
        final_corners.append(pt[0][0])
    
    return np.array(final_corners)


object_points = get_points(object_mask)
object_points